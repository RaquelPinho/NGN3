---
title: "Off-target evaluation of CRISPRs/Cas9 system targeting gene NGN3 in porcine embryos"
author: "Raquel"
date: "4/29/2020"
output: 
 ioslides_presentation:
   css: temp1.css
runtime: shiny
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = "D:/Raquel/Desktop/Post_doc/NGN3/NGN3_R")
knitr::opts_chunk$set(echo = FALSE)
```

## NGN3 variants analysis

The analysis of the variantes of off target loci from NGN3 guides in porcines.The guide used was CCCGCGCAGCGCAUCCAACG.

### Libraries used  

I will use mainly the CrispRVariants package, for plotting ggplot2 and for importing the data rtracklayer.

```{r libraries, echo = FALSE, include=FALSE}
library("ggplot2")
library("CrispRVariants")
library("Rsamtools")
library("gdata")
library("rtracklayer")
library("gridExtra")
library("shiny")
library("plotly")
library("GenomicFeatures")
library("dplyr")
library("viridis")
library("wesanderson")
library("reshape")
library("ggpubr")
library("superheat")
```

```{r functions, echo = FALSE, include=FALSE}
import::here(.from = "D:/Raquel/Desktop/Post_doc/Codes/annotation_visualization_lib.R",
             plotAnnotation_Mod,
             arrangePlots.
             mut.efficiency)
```


### Samples and metadata 

Samples from blastocysts derivides from IVF (BL) or parthenogenesis (PT) were analyzed with targeted sequencing for the target region (NGN3) and 7 predicted off-target sites (OF) 


```{r set_samples, include=F, echo=FALSE}
# Setting up the working directory
setwd("D:/Raquel/Desktop/Post_doc/NGN3/NGN3_R")

# Read samples files, each .bam file are the reads for all (target/offtarget) sites for one sample.
readfiles<-list.files("./Bam")

# Creating metadata table for samples:
Samples <- gsub(".sort.bam", "", readfiles)
Group <- vector(mode = "character", length = length(readfiles))
Files <- file.path("./Bam",readfiles)
Group[grep("PTM",readfiles)] <- "Parthenotes_M" 
Group[grep("BL",readfiles)] <- "Blastocysts" 
Group[grep("BLM",readfiles)] <- "Blastocysts_M" 
Group[grep("CL",readfiles)] <- "Control" 
metadata <- data.frame (Samples, Files = Files, Group)
metadata
# Loading references and bed file
## I saved the fasta files with the reference sequences and the GRange objects of the target / off target regions in a .RData file
load("./NGN3.RData")
txlocigff <-makeTxDbFromGFF("loci.gff" ,format = "gff")
# where gd2 is the GRange of the target regions,
# the references2 is a DNAStringSet, with the sequences, 
# crispr_set3_all, a crispr set with all the samples but targeting only the NGN3 locus
# locimetadata is a df with the information of the loci
# txlocigff is a TxDb of the regions containing the target and off target regions in the pig genome GCF_000003025.6_Sscrofa11.1_genomic


```
## Loci information

```{r locimetadata}
ui <- fluidPage(
  # define title of the panel
  titlePanel("Loci metadata"),
  # define input
  sidebarLayout( 
    sidebarPanel( 
      selectInput( inputId = "Loci", label = "Choose target / off-target (OF) region", choices = locimetadata$ID)),
    # define output 
    mainPanel(
      DT::dataTableOutput("table")
    )))
# define server logic options
server <- function(input, output) {
  tableInput <-  reactive({
    switch(input$`Loci metadata`, locimetadata$ID)
  })
  itable <-reactive({
    table <- locimetadata[locimetadata$ID == input$Loci, -11]
    table <- t(as.matrix(table))
    colnames(table) <- "Loci"
    table
  })

output$table <-DT::renderDataTable(
  itable(), extension = "Buttons", options = list(dom = "Bfrtip", buttons = list("pdf", "csv", "excel","print"))
)
}

# Run the application 
shinyApp(ui = ui, server = server)

```

## Choosing the loci for the analysis

```{r loci_choice}
ui <- fluidPage(
  # define title of the panel
  titlePanel("Loci"),
  # define input
  sidebarLayout( 
    sidebarPanel( 
      selectInput( inputId = "Loci", label = "Choose target / off-target (OF) region", choices = gd$names)),
    # define output 
    mainPanel(
      textOutput("Locus")
    )))
# define server logic options
server <- function(input, output) {
   Loci <- reactive({input$Loci})
   output$Locus <- renderPrint({
    paste("Using CrisprSet object created targeting", input$Loci, "within all samples.")
})
  observe({
  Locus <<- input$Loci
  })
}
# Run the application 
shinyApp(ui = ui, server = server)
```


## Variant frequency at the target site by group 

- The allele and mutation frequency was calculated using the CrispRVariants 
- The GCF_000003025.6_Sscrofa11.1_genomic database downloaded from the NCBI. 
- 1 control (CL) sample for the blastocysts and one control for the parthenotes 
- Displaying alleles with more the 10% frequency
- Samples were diveded in 4 groups: Blastocysts, Blastocysts_M (potencially mosaic), Partenotes_M ( potencially mosaic), Controls. The controls samples are also going to be presented when a group that is not control is chosen.

## 

```{r freq_group, out.height = "110%", out.width = "110%"}
vc <- variantCounts(crispr_set3_all)
ui2 <- fluidPage(
    # define title of the panel
    titlePanel("Group"),
    # define input
    sidebarLayout( 
        sidebarPanel( 
            selectInput( inputId = "Group", label = "Choose group", choices = unique(metadata$Group))),
    # define output 
    mainPanel(
        plotOutput("heat_s_plot")
    )))
# define server logic options
server2 <- function(input, output) {
    Input <-  reactive({
        switch(input$Group, unique(metadata$Group))
            })
    InputS <- reactive({
    	order <- unique(c(which(metadata$Group %in% input$Group), which(metadata$Group == "Control")))
    })

    output$heat_s_plot <-renderPlot({
        plotFreqHeatmap(crispr_set3_all, min.freq = 0.1, order = InputS(), plot.text.size = 4, legend.text.size = 12, x.hjust = 1 )
            }, height = 750, width = 700)
}

# Run the application 
shinyApp(ui = ui2, server = server2)

```

## Variant frequency at the target site by sample

- The allele and mutation frequency was calculated using the CrispRVariants 
- The GCF_000003025.6_Sscrofa11.1_genomic database downloaded from the NCBI. 
- 1 control (CL) sample for the blastocysts and one control for the parthenotes 
- Displaying alleles with more the 10% frequency

## 
```{r freq_sample, out.height = "110%", out.width = "110%"}
ui2 <- fluidPage(
    # define title of the panel
    titlePanel("Samples"),
    # define input
    sidebarLayout( 
        sidebarPanel( 
            selectInput( inputId = "Samples", label = "Choose sample(s)", choices = metadata$Samples, multiple = TRUE)),
    # define output 
    mainPanel(
        plotOutput("heat_s_plot")
    )))
# define server logic options
server2 <- function(input, output) {
    Input <-  reactive({
        switch(input$Samples, metadata$Samples)
            })
    InputS <- reactive({
    	order <- which(gsub('.sort.bam', '', colnames(vc)) %in% input$Samples)
    })

    output$heat_s_plot <- renderPlot({
        plotFreqHeatmap(crispr_set3_all, min.freq = 0.1, order = InputS(), plot.text.size = 4, legend.text.size = 12, x.hjust = 1 )
            }, height = 750, width = 700)
}

# Run the application 
shinyApp(ui = ui2, server = server2)

```

## Alignment plot 

- the alignemst plots were criated using the function PlotAlignrments and annotateGenePlot and the annotation provided by the .GFF file from the loci downloaded at NCBI.

##
```{r plot_obj, out.height = "110%", out.width = "110%"}
amp_ranges1 <- readRDS(file = "./amp_ranges_NGN3.RData")
ui2 <- fluidPage(
    # define title of the panel
    titlePanel("Locus"),
    # define input
    sidebarLayout( 
        sidebarPanel( 
            selectInput( inputId = "Locus", label = "Choose locus(s)", choices = amp_ranges1$ID)),
    # define output 
    mainPanel(
        plotOutput("Alignment")
    )))

# define server logic options
server2 <- function(input, output) {
    InputL <- reactive({
      top_p <- plotAnnotation_Mod(txlocigff, Locus = input$Locus, crispr_set3_all, amp_ranges1, gd2)
    })
      
        order <- grep("CL",colnames(vc))
    	
    	r_plot <- plotFreqHeatmap(crispr_set3_all, min.freq = 0.1, order = order, plot.text.size = 4) 

      l_plot <- plotAlignments(crispr_set3_all, min.freq = 0.1, legend.cols = 5, ins.size = 4, legend.symbol.size = 5, legend.text.size = 8, axis.text.size = 10)


    output$Alignment <- renderPlot({
        arrangePlots(top.plot =  InputL(), left.plot =  l_plot, right.plot =  r_plot, col.wdth.ratio = c(6,1))
            }, height = 900, width = 1200)
}

# Run the application 
shinyApp(ui = ui2, server = server2)

```

## Mutation Efficiency

- Mutation Frequency is calculated by dividing the sum of all reads with alleles non-SNV by the total reads. I will also exclude the reads occouring in the control since they might be sequencing error.

- I also sed the log10 of the frequencies of each allele to create a violin plot. I used the log10 because the majority of the alleles had  0 reads for any given sample.

##
```{r mut_efficiency}
#creating the frequency table
total_reads <-apply(vc,2,sum)
vcc <- sweep(vc, 2,total_reads , '/')
# creating palette to be used in the plots
palette <-wes_palette("GrandBudapest1",3)
# Calculation of mutation frequency including control reads
rows_SNV <- grep("SNV", rownames(vc))
mut_reads <- apply(vc[-rows_SNV,],2,sum)
mut_eff <- mut_reads / total_reads
# Calculation of mutation frequency excluding control reads
controls <- grep("CL", colnames(vc))
reads_control <- unique(c(which(vc[,controls[1]] != 0 | vc[,controls[2]] != 0), rows_SNV))
mut_reads_nc <- apply(vc[-reads_control,], 2, sum)
mut_eff_nc <- mut_reads_nc / total_reads
#Creating the summary (mean , min and max efficiency)
mut_eff_dt <- as.data.frame(rbind(mut_eff, mut_eff_nc))
sum_m <- mut_eff_dt %>% t() %>% as.data.frame() %>% summarise_all(.funs = list(
         mean = mean,
         min = min,
         max = max), na.rm=TRUE)  %>% matrix(2,3)
colnames(sum_m) <- c( "Mean", "Min", "Max")
rownames(sum_m) <- rownames(mut_eff_dt)
mut_eff <- transform(merge(mut_eff_dt, sum_m, by=0, all=TRUE), row.names=Row.names, Row.names=NULL)
rownames(mut_eff) <- c("Mut.efficiency", "Mut.efficiency.wo.controlreads")
colnames(mut_eff) <- gsub(".sort.bam","",colnames(mut_eff)) 
# Now displyaing it in shiny
ui <- fluidPage(
  # define title of the panel
  titlePanel("Mutation Efficiency"),
  # define input
  sidebarLayout( 
    sidebarPanel( 
      selectInput( inputId = "Sample", label = "Choose sample", choices = metadata$Samples)),
    # define output 
    mainPanel(
      tableOutput("table"),
      plotOutput("violin")
    )))
# define server logic options
server <- function(input, output) {
  
    # creating data frame for the violin plot

  p_df <- reactive({ 
        # selecting sample
    match <- c(input$Sample, "BLCL","PTMCL")
    match <- unique(grep(paste(match,collapse="|"), 
                        colnames(vcc), value=TRUE))
    ptable <- melt(as.data.frame(vcc[, match]))
    ptable$log10 <- log10(ptable$value)
    colnames(ptable) <- c("Sample","Freq","Log10")
    ptable
  })

output$table <-renderTable({
  #creating table with only info of interest
  table <- mut_eff[, which(colnames(mut_eff) %in% c(input$Sample, "Min", "Mean", "Max")) ]
  table
  }, rownames = TRUE)

output$violin <- renderPlot({
  ggviolin(p_df(), "Sample", "Log10", color = "black" , fill = "Sample", palette = palette)
}, height = 550, width = 600)
}

# Run the application 
shinyApp(ui = ui, server = server)

```

## Variant Frequency

- The variant/allele frequency is correlated with the read counts corresposding to that allele.

- It renders clearer visualization since there is a big variance in total number of reads per sample.

##
```{r var_freq, out.height = "110%", out.width = "110%"}
#Getting the alleles / variants with total frequency (considering all samples) greater than 0.1 (10%)
freq_0.1 <- apply(vcc, 1, sum)
freq_0.1 <- freq_0.1 > 0.1
vcc_0.1 <- vcc[freq_0.1,]
vcc_0.1 <- signif(vcc_0.1, digits = 2)
row.names(vcc_0.1)[1] <- "No variant"
colnames(vcc_0.1) <- gsub(".sort.bam", "", colnames(vcc_0.1))
# creating palette to be used in the plots
palette <- wes_palette("GrandBudapest1",3)
# creating heatplot with the frequency matrix
superheat(vcc_0.1, order.rows = order(1:45, decreasing = T), heat.pal = palette, heat.lim = c(0.01,1), heat.na.col = "#b3e2cd",left.label.col = "lavenderblush1", left.label.size = 0.06, left.label.text.size = 4   , bottom.label.size = 0.2, bottom.label.text.size = 4, bottom.label.text.angle = 90, bottom.label.col = "lavenderblush1", title = "Variants frequencies" ,title.alignment = "center", row.title = "Variants", column.title = "Samples", X.text = signif(vcc_0.1, digits = 1) , X.text.size = 2.2, X.text.col = ifelse(vcc_0.1 > 0.6,"white","black"))

# Now displyaing it in shiny
ui <- fluidPage(
  # define title of the panel
  titlePanel("Mutation Efficiency"),
  # define input
  sidebarLayout( 
    sidebarPanel( 
      selectInput( inputId = "Sample", label = "Choose sample", choices = metadata$Samples)),
    # define output 
    mainPanel(
      tableOutput("table"),
      plotOutput("violin")
    )))
# define server logic options
server <- function(input, output) {
  
    # creating data frame for the violin plot

  p_df <- reactive({ 
        # selecting sample
    match <- c(input$Sample, "BLCL","PTMCL")
    match <- unique(grep(paste(match,collapse="|"), 
                        colnames(vcc), value=TRUE))
    ptable <- melt(as.data.frame(vcc[, match]))
    ptable$log10 <- log10(ptable$value)
    colnames(ptable) <- c("Sample","Freq","Log10")
    ptable
  })

output$table <-renderTable({
  #creating table with only info of interest
  table <- mut_eff[, which(colnames(mut_eff) %in% c(input$Sample, "Min", "Mean", "Max")) ]
  table
  }, rownames = TRUE)

output$violin <- renderPlot({
  ggviolin(p_df(), "Sample", "Log10", color = "black" , fill = "Sample", palette = palette)
}, height = 550, width = 600)
}

# Run the application 
shinyApp(ui = ui, server = server)

```