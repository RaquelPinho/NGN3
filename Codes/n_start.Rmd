---
title: "start_shiny"
author: "Raquel Pinho"
date: "5/14/2020"
output: 
  html_document:
   css: temp1.css
runtime: shiny
---

---
title: "Off-target evaluation of CRISPRs/Cas9 system targeting gene NGN3 in porcine embryos"
author: "Raquel"
date: "4/29/2020"
output: 
 ioslides_presentation:
   css: temp.css
runtime: shiny
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = "D:/Raquel/Desktop/Post_doc/NGN3/NGN3_R")
knitr::opts_chunk$set(echo = FALSE)
```

## NGN3 variants analysis

The analysis of the variantes of off target loci from NGN3 guides in porcines.The guide used was CCCGCGCAGCGCAUCCAACG.

### Libraries used  

I will use mainly the CrispRVariants package, for plotting ggplot2 and for importing the data rtracklayer.

```{r libraries, echo = FALSE, include=FALSE}
library("ggplot2")
library("CrispRVariants")
library("Rsamtools")
library("gdata")
library("rtracklayer")
library("gridExtra")
library("shiny")
library("plotly")
library("GenomicFeatures")
library("reshape")
library("wesanderson")
library("dplyr")
library("ggpubr")
library("superheat")
```

```{r functions, echo = FALSE, include=FALSE}
import::here(.from = "D:/Raquel/Desktop/Post_doc/Codes/annotation_visualization_lib.R",
             plotAnnotation_Mod,
             arrangePlots,
             mut.efficiency,
             filter.alleles,
             filter.allAlleles,
             plotConservation,
             Mut.eff.threshold,
             Plot.Cum.dens,
             Mut.eff.all.threshold)
```


### Samples and metadata 

Samples from blastocysts derivides from IVF (BL) or parthenogenesis (PT) were analyzed with targeted sequencing for the target region (NGN3) and 7 predicted off-target sites (OF) 


```{r set_samples, include=F, echo=FALSE}
# Setting up the working directory
setwd("D:/Raquel/Desktop/Post_doc/NGN3/NGN3_R")

# Read samples files, each .bam file are the reads for all (target/offtarget) sites for one sample.
readfiles<-list.files("./Bam")

# Loading reference, GRange objects, trancript database and metadatas
## I saved the fasta files with the reference sequences and the GRange objects of the target / off target regions in a .RData file
load("./NGN3_Robj.RData")
## where gd is the GRange of the target regions,
## amp_ranges is the GRanges of  the amplicon regions with seqlevels as the ncbi id in the transcript database
## the references is a DNAStringSet, with the references sequences of the loci of target and off-target sites, 
## locimetadata is a df with the information of the loci,
## metadata is the metadata of the samples with the information of file paths and group information
# Loading the list of the CristrSet for the loci in the sequencing
load(file = "./CrisprSets.RData")
list2env(All_sets, envir=.GlobalEnv)

```

## Loci information 
```{r locimetadata}
ui <- fluidPage(
  # define title of the panel
  titlePanel("Loci metadata"),
  # define input
  sidebarLayout( 
    sidebarPanel( 
      selectInput( inputId = "Loci", label = "Choose target / off-target (OF) region", choices = locimetadata$ID)),
    # define output 
    mainPanel(
      DT::dataTableOutput("table"),
      )))
# define server logic options
server <- function(input, output) {
  tableInput <-  reactive({
    switch(input$`Loci metadata`, locimetadata$ID)
  })
  itable <-reactive({
    table <- locimetadata[locimetadata$ID == input$Loci, -11]
    table <- t(as.matrix(table))
    colnames(table) <- "Loci"
    table
  })

  output$table <-DT::renderDataTable(
  itable(), extension = "Buttons", options = list(dom = "Bfrtip", buttons = list("pdf", "csv",          "excel","print"), pageLength = 11)
)
}

# Run the application 
shinyApp(ui = ui, server = server)
```


```{r creating_vc_all_list,include=F, echo=FALSE}
vc_all_list <- lapply(All_sets,variantCounts)
names(vc_all_list) <- gsub("crisprset_", "", names(All_sets))
```

## Variant frequency at the target site by group 

- The allele and mutation frequency was calculated using the CrispRVariants 
- 1 control (CL) sample for the blastocysts and one control for the parthenotes 
- Displaying alleles with more the 10% frequency
- Samples were diveded in 4 groups: Blastocysts, Blastocysts_M (potencially mosaic), Partenotes_M ( potencially mosaic), Controls. The controls samples are also going to be presented when a group that is not control is chosen.

## 

```{r freq_group, out.height = "110%", out.width = "110%"}
ui2 <- fluidPage(
    # define title of the panel
    titlePanel("Group"),
    # define input
    sidebarLayout( 
      sidebarPanel( 
            selectInput(inputId = "Locus", label = "Choose target / off-target (OF) region", choices = gd$names),
            selectInput( inputId = "Group", label = "Choose group", choices = unique(metadata$Group))),
    # define output 
    mainPanel(
        plotOutput("heat_s_plot")
    )))
# define server logic options
server2 <- function(input, output) {
    InputG <-  reactive({
        switch(input$Group, unique(metadata$Group))
            })
    InputS <- reactive({
      samples_dt <- metadata[which(metadata$Samples %in% colnames(vc_all_list[[input$Locus]])),]
      order <- unique(c(which(samples_dt$Group %in% input$Group), which(samples_dt$Group == "Control")))
    })
    InputL <- reactive({
      get(paste0("crisprset_", input$Locus))
    })
    output$heat_s_plot <-renderPlot({
        plotFreqHeatmap(InputL(), min.freq = 0.1, order = InputS(), plot.text.size = 4, legend.text.size = 12, x.hjust = 1 )
            }, height = 750, width = 700)
}

# Run the application 
shinyApp(ui = ui2, server = server2)

```

## Variant frequency at the target site by sample

- The allele and mutation frequency was calculated using the CrispRVariants 
- The GCF_000003025.6_Sscrofa11.1_genomic database downloaded from the NCBI. 
- 1 control (CL) sample for the blastocysts and one control for the parthenotes 
- Displaying alleles with more the 10% frequency

## 
```{r freq_sample, out.height = "110%", out.width = "110%"}
ui2 <- fluidPage(
    # define title of the panel
    titlePanel("Samples"),
    # define input
    sidebarLayout( 
      sidebarPanel( 
            selectInput(inputId = "Locus", label = "Choose target / off-target (OF) region", choices = gd$names),
            selectInput( inputId = "Samples", label = "Choose sample", choices = unique(metadata$Samples), multiple = TRUE)),
    # define output 
    mainPanel(
        plotOutput("heat_s_plot")
    )))
# define server logic options
server2 <- function(input, output) {
    Input <-  reactive({
        switch(input$Samples, metadata$Samples)
            })
    InputS <- reactive({
      order <- which(colnames(vc_all_list[[input$Locus]]) %in% input$Samples)
    })
    InputC <- reactive({
      get(paste0("crisprset_", input$Locus))
    })

    output$heat_s_plot <- renderPlot({
        plotFreqHeatmap(InputC(), min.freq = 0.1, order = InputS(), plot.text.size = 4, legend.text.size = 12, x.hjust = 1 )
            }, height = 750, width = 700)
}

# Run the application 
shinyApp(ui = ui2, server = server2)

```


## Alignment plot 

- the alignemst plots were criated using the function PlotAlignrments and annotateGenePlot and the annotation provided by the .GFF file from the loci downloaded at NCBI.

```{r import_txdb, echo=FALSE,include=FALSE}
txlocigff <-makeTxDbFromGFF("loci.gff" ,format = "gff")
```

##
```{r plot_obj}
ui2 <- fluidPage(
    # define title of the panel
    titlePanel("Locus"),
    # define input
    sidebarLayout( 
        sidebarPanel( 
            selectInput( inputId = "Locus", label = "Choose locus(s)", choices = amp_ranges$ID)),
    # define output 
    mainPanel(
        plotOutput("Alignment")
    )))

# define server logic options
server2 <- function(input, output) {
    
    InputCL <- reactive({
      order <- grep("CL",colnames(vc_all_list[[input$Locus]]))
    })
    InputCR <- reactive({
      get(paste0("crisprset_", input$Locus))
    })  
    Input_top <- reactive({
      top_p <- plotAnnotation_Mod(txlocigff, Locus = input$Locus, InputCR(), amp_ranges, gd)
    })
      Input_r <- reactive({
        r_plot <- plotFreqHeatmap(InputCR(), min.freq = 0.1, order = order, plot.text.size = 4, legend.text.size = 12, x.hjust = 1 ) 
      })
      Input_l <- reactive({
      l_plot <- plotAlignments(InputCR(), min.freq = 0.1, legend.cols = 5, ins.size = 4, legend.symbol.size = 5, legend.text.size = 8, axis.text.size = 10)
          })

    output$Alignment <- renderPlot({
        arrangePlots(top.plot =  Input_top(), left.plot =  Input_l(), right.plot =  Input_r(), col.wdth.ratio = c(6,1))
            }, height = 900, width = 1000)
}

# Run the application 
shinyApp(ui = ui2, server = server2)

```

## Mutation Efficiency

- Mutation Frequency is calculated by dividing the sum of all reads with alleles non-SNV by the total reads. I will also exclude the reads occouring in the control since they might be sequencing error.

- I also sed the log10 of the frequencies of each allele to create a violin plot. I used the log10 because the majority of the alleles had  0 reads for any given sample.

##

```{r mut_efficiency}
#define palette
palette <- wes_palette("GrandBudapest1",3)
# Now displyaing it in shiny
ui <- fluidPage(
  # define title of the panel
  titlePanel("Mutation Efficiency"),
  # define input
  sidebarLayout( 
    sidebarPanel( 
      selectInput( inputId = "Sample", label = "Choose sample", choices = metadata$Samples),
      selectInput( inputId = "Locus", label = "Choose locus", choices = gd$names)),
    # define output 
    mainPanel(
      tableOutput("table"),
      plotOutput("violin"),
      )))
# define server logic options
server <- function(input, output) {
  #loading crisprset 
  InputCR <- reactive({
      get(paste0("crisprset_", input$Locus))
    })  
  #creating mutation efficiency table  
  InputM <- reactive({
    mt_data <- mut.efficiency(InputCR())
    })
 
  # creating data frame for the violin plot
  p_df <- reactive({ 
        # selecting sample
    dt <- InputM()[[2]]
    match <- c(input$Sample, "BLCL","PTMCL")
    match <- unique(grep(paste(match,collapse="|"), 
                       colnames(dt), value=TRUE))
    ptable <- melt(as.data.frame(dt[, match]))
    ptable$log10 <- log10(ptable$value)
    colnames(ptable) <- c("Sample","Freq","Log10")
    ptable
  })

output$table <-renderTable({
  #creating table with only info of interest
  table <- InputM()[[1]][, which(colnames(InputM()[[1]]) %in% c(input$Sample, "Min", "Mean", "Max")) ]
  table
  }, rownames = TRUE)
  
output$violin <- renderPlot({
  ggviolin(p_df(), "Sample", "Log10", color = "black" , fill = "Sample", palette = palette)
}, height = 550, width = 600)
}

# Run the application 
shinyApp(ui = ui, server = server)

```

## Variant Frequency

- The variant/allele frequency is correlated with the read counts corresposding to that allele.

- It renders clearer visualization since there is a big variance in total number of reads per sample.

##
```{r var_freq, out.height = "110%", out.width = "120%"}
#define palette
palette <- wes_palette("GrandBudapest1",3)
# Now displyaing it in shiny
ui3 <- fluidPage(
    # define title of the panel
    titlePanel("Locus Variance"),
    # define input
    sidebarLayout( 
      sidebarPanel( 
            selectInput(inputId = "Locus", label = "Choose target / off-target (OF) region", choices = gd$names)),
    
    # define output 
    mainPanel(
        plotOutput("superheat"),
         )))
# define server logic options
server3 <- function(input, output) {
      InputV <- reactive({

      vc_all <-vc_all_list[[input$Locus]]
      total_reads <-apply(vc_all,2,sum)
      vcc <- sweep(vc_all, 2,total_reads , '/')
      #Getting the alleles / variants with total frequency (considering all samples) greater than 0.1 (10%)
      freq_0.1 <- apply(vcc, 1, sum)
      freq_0.1 <- freq_0.1 > 0.1
      vcc_0.1 <- vcc[freq_0.1,]
      vcc_0.1 <- signif(vcc_0.1, digits = 2) 
      rownames(vcc_0.1)[1] <- "No variant"
      vcc_0.1
     
        })

      InputT <- reactive({

      X.text = ifelse(InputV() > 0.1, signif(InputV(), digits = 1), paste(" "))

    })

      InputO <- reactive({

        order <- order(1:nrow(InputV()), decreasing = T)
      })

     output$superheat <-renderPlot({
     
       superheat(InputV(), order.rows = InputO(), heat.pal = palette, heat.lim = c(0.01,1), heat.na.col = "#b3e2cd",left.label.col = "lavenderblush1", left.label.size = 0.1, left.label.text.size = 4, bottom.label.size = 0.2, bottom.label.text.size = 4, bottom.label.text.angle = 90, bottom.label.col = "lavenderblush1", title = "Variants frequencies" ,title.alignment = "center", row.title = "Variants", column.title = "Samples", X.text = InputT() , X.text.size = 2.6, X.text.col = ifelse(InputV() > 0.6,"white","black"))
            }, height = 900, width = 1200)
} 
    output$test <- renderPrint({
      head(inputV()[,10])
    })

# Run the application 
shinyApp(ui = ui3, server = server3)
```

## Mutation frequencing with read counts threshold

- I choose a threshold (0.9) for removing 10% of the reads accounting for the alleles with lower frequencing before calculating the mutation frequency since I think that this method accounts for the sequencing eros without considering the reads from the controls as reference for the error removal from the other samples since the error is supousedly random and there were more than 8000 alleles more then 99 % of them with zero reads for a given sample. The mutation eff, min, max and sd were calculation not accounting for the control samples.

- The conservation of read counts and the allele conservation per thrshold level 

## 

```{r mu_eff_thr, out.height = "110%", out.width = "120%" }
# Now displyaing it in shiny
ui <- fluidPage(
  # define title of the panel
  titlePanel("Mutation Efficiency"),
  # define input
  sidebarLayout( 
    sidebarPanel( 
      selectInput( inputId = "Sample", label = "Choose sample", choices = metadata$Samples),
      selectInput( inputId = "Locus", label = "Choose locus", choices = gd$names)),
    # define output 
    mainPanel(
      tableOutput("table"),
      plotOutput("Conservation"),
      )))
# define server logic options
server <- function(input, output) {
      # Getting functions to create mutation efficiency table and plot
    InputM  <- reactive({ 
        # selecting sample
    mut_eff <- Mut.eff.all.threshold(colname= input$Sample, readMatrix = vc_all_list[[input$Locus]])
    })

output$table <-renderTable({
  #creating table with only info of interest
  InputM()
  }, rownames = FALSE)

output$Conservation <- renderPlot({
  plotConservation(vc_all_list[[input$Locus]])
}, height = 450, width = 600)
}

# Run the application 
shinyApp(ui = ui, server = server)

```

## Mutation frequencing with read counts threshold

- we can also see what as the threshold on read counts per allele (when the threshold of 0.9 for total read counts is used)


## 
```{r cum_den, out.height = "110%", out.width = "120%" }
# Now displyaing it in shiny
ui <- fluidPage(
  # define title of the panel
  titlePanel("Allele cumulative density"),
  # define input
  sidebarLayout( 
    sidebarPanel( 
      selectInput( inputId = "Sample", label = "Choose sample", choices = metadata$Samples),
      selectInput( inputId = "Locus", label = "Choose locus", choices = gd$names)),
    # define output 
    mainPanel(
      plotOutput("CumDensity"),
      )))
# define server logic options
server <- function(input, output) {
      # Getting functions to create mutation efficiency table and plot
    InputC  <- reactive({ 
        # selecting sample
    vc_all <- vc_all_list[[input$Locus]]
    col <- vc_all[,input$Sample]
            })

    output$CumDensity<- renderPlot({
  Plot.Cum.dens(InputC())
}, height = 450, width = 600)
}

# Run the application 
shinyApp(ui = ui, server = server)

```